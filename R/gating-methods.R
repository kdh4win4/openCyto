#' Applies gatingTemplate to one GatingSet.
#'
#' It loads the gating methods by topological order and applies them to \code{GatingSet}.
#'
#' @param x a \code{gatingTemplate} object
#' @param y a \code{GatingSet} object
#' @param env_fct a \code{environment} that contains \code{fcTree} object named as 'fct'. If NULL (by default), no \code{fcTree} will be constructed. It is currently reserved for the internal debugging.
#' @param ... 
#'  \itemize{
#'      \item{start}{ a \code{character} that specifies the population (correspoding to 'alias' column in csv template) where the gating prcoess will start from. It is useful to quickly skip some gates and go directly to the target population in the testing run. Default is "root".}
#'      \item{stop.at}{ a \code{character} that specifies the population (correspoding to 'alias' column in csv template) where the gating prcoess will stop at. Default is NULL, indicating the end of gating tree.}
#'      \item{mc.cores}{ passed to \code{multicore} package for parallel computing}
#'      \item{parallel_type}{  \code{character} specifying the parallel type. The valid options are "none", "multicore", "cluster".}
#'      \item{cl}{ \code{cluster} object passed to \code{parallel} package (when \code{parallel_type} is "cluster")}
#'  }  
#' 
#' 
#' @return 
#' Nothing. As the side effect, gates generated by gating methods are saved in \code{GatingSet}. 
#' @examples
#' \dontrun{
#'  gt <- gatingTemplate(file.path(path, "data/ICStemplate.csv"), "ICS")
#'  gs <- GatingSet(fs) #fs is a flowSet/ncdfFlowSet
#'  gating(gt, gs)
#'  gating(gt, gs, stop.at = "v") #proceed the gating until population 'v'
#'  gating(gt, gs, start = "v") # start from 'v'
#'  gating(gt, gs, parallel_type = "multicore", mc.cores = 8) #parallel gating using multicore
#'  #parallel gating by using cluster
#'  cl1 <- makeCluster (8, type = "MPI")
#'  gating(gt, gs, parallel_type = "cluster", cl = cl1)
#'  stopCluster ( cl1 )
#' }
#' @rdname gating-methods
#' @importFrom flowWorkspace gating
#' @export
#' @aliases 
#' gating,gatingTemplate,GatingSet-method
setMethod("gating", signature = c("gatingTemplate", "GatingSet"),
    definition = function(x, y, env_fct = NULL, ...) {
      .gating_gatingTemplate(x,y,env_fct,...)
    })

#' @aliases 
#' gating,gatingTemplate,GatingSetList-method
#' @rdname gating-methods
setMethod("gating", signature = c("gatingTemplate", "GatingSetList"),
    definition = function(x, y, env_fct = NULL, ...) {
      .gating_gatingTemplate(x,y,env_fct,...)
    })
#' internal function (gating_gatingTemplate)
#'  
#' @param stop.at a \code{character} that specifies the population (correspoding to 'alias' column in csv template) where the gating prcoess will stop at.
#' @param start a \code{character} that specifies the population (correspoding to 'alias' column in csv template) where the gating prcoess will start from. It is useful to quickly skip some gates and go directly to the target population in the testing run. 
#' @param ... other arguments passed to the gatingMethod-specific \code{gating} methods.
#' @importFrom RBGL tsort
#' @importFrom plyr ldply
.gating_gatingTemplate <- function(x, y, env_fct = NULL, start = "root", stop.at = NULL, ...) {
  gt <- x
  if (!is.null(env_fct)) {
    # use the fcTree if already exists
    if (exists("fct", env_fct)) {
      fct <- get("fct", env_fct)
    } else {
      # create one from gt if not
      fct <- fcTree(gt)
      assign("fct", fct, env_fct)
    }
    
  }
  
  nodePaths <- names(sapply(getNodes(gt),alias))
    #validity check for stop.at argument
  if(!is.null(stop.at)){
    #escape meta character
    stop.pat <- gsub("\\+", "\\\\+", stop.at)
    stop.pat <- paste0(stop.pat, "$")
    if(substr(stop.at, 1,1) != "/")
      stop.pat <- paste0("/", stop.pat) #prepend path delimiter to avoid partial node name matching
    
    matchInd <- grep(stop.pat, nodePaths)
    if(length(matchInd) == 0)
      stop("Can't find stop point: ", stop.at)
    else if(length(matchInd) > 1)
      stop("ambiguous stop point: ", stop.at)
  }
  # gate each node 
  gt_nodes <- tsort(gt)[-1]#by the topological order

  #try to skip some nodes to save time
  if(start != "root"){
    #escape meta character
    start.pat <- gsub("\\+", "\\\\+", start)
    start.pat <- paste0(start.pat, "$") #treat it as terminal node
    if(substr(start, 1,1) != "/")
      start.pat <- paste0("/", start.pat) #prepend path delimiter to avoid partial node name matching
    matchInd <- grep(start.pat, nodePaths)
    
    if(length(matchInd) == 0)
      stop("Can't find start point: ", start)
    else if(length(matchInd) > 1)
      stop("ambiguous start point: ", start)
    
    gt_nodes <- gt_nodes[matchInd:length(gt_nodes)]
  }  
    
                   
  for (node in gt_nodes) {
    
    # get parent node to gate
    gt_node_pop <- getNodes(gt, node)
    parent <- getParent(gt, node)
    
    if(!is.null(stop.at)){
      nodeName <- alias(gt_node_pop)
      nodePath <- file.path(parent, nodeName)
      matchInd <- grep(stop.pat, nodePath)
      if(length(matchInd) == 1)
      {
        message("stop at: ",stop.at)
        break
      }
      
    }    
    # extract gate method from one edge(since multiple edge to the same node is
    # redudant)
    this_gate <- getGate(gt, parent, node)
    
    #get preprocessing method
    this_ppm <- ppMethod(gt, parent, node)
    
    parentInd <- match(parent, getNodes(y[[1]], showHidden = TRUE))
    if (is.na(parentInd)) 
      stop("parent node '", parent, "' not gated yet!")
    
    #preprocessing
    pp_res <- NULL
#    browser()
    if(class(this_ppm) == "ppMethod")
      pp_res <- preprocessing(x = this_ppm, y, parent = parent, gtPop = gt_node_pop, gm = this_gate, ...)
#    browser()
    # pass the pops and gate to gating routine
    filterObj <- gating(x = this_gate, y, parent = parent, gtPop = gt_node_pop, pp_res = pp_res, ...)
    # update fct
    if (!is.null(env_fct) && !is.null(filterObj)) {
      nodeData(env_fct$fct, node, "fList")[[1]] <- filterObj
    }  
    
    
  }
  message("finished.")
}


#' apply a \link[openCyto:gtMethod-class]{gtMethod} to the \code{GatingSet}
#' 
#' 
#' @inheritParams .gating_gtMethod
#' @param ... other arguments
#' @aliases
#' gating,gtMethod,GatingSet-method 
#' gating,gtMethod,GatingSetList-method
setMethod("gating", signature = c("gtMethod", "GatingSet"),
    definition = function(x, y, ...) {
      .gating_gtMethod(x,y,...)
    })
setMethod("gating", signature = c("gtMethod", "GatingSetList"),
    definition = function(x, y, ...) {
      .gating_gtMethod(x,y,...)
    })
#' internal function (gating_gtMethod)
#' 
#' It is a generic gating function that does:
#' 1. parse the gating parameters
#' 2. group the data when applicable 
#' 3. apply parallelism when applicable  
#' 4. pass the flow data(maybe grouped) and preprocessing results to the adaptor function ".gating_adaptor"
#' 5. collect the gates and add to GatingSet object
#' 
#' 
#'  @param x \code{gtMethod}
#'  @param y \code{GatingSet}
#'  @param gtPop a \code{gtPopulation} object that contains the information of the cell population that is going to be generated by this gating method.
#'  @param  parent \code{character} specifying the parent node within \code{GatingSet} to which the new popoulation is to be attached.
#'  @param  pp_res \code{list} the preprocessing results to be used by the gating method. The names of the list has to be matched to the sample names of the data.
#'  @param  mc.cores passed to \code{multicore} package for parallel computing
#'  @param  parallel_type \code{character} specifying the parallel type. The valid options are "none", "multicore", "cluster".
#'  @param  cl \code{cluster} object passed to \code{parallel} package
#'  @import flowWorkspace
#'  @importFrom flowCore getChannelMarker
.gating_gtMethod <- function(x, y, gtPop, parent, pp_res 
            , mc.cores = getOption("mc.cores", 2L), parallel_type = c("none", "multicore", "cluster"), cl = NULL
            ,  ...) {
  
  require("parallel")
#  browser()
  gFunc_args <- parameters(x)

  # HOTFIX: This resolve an error when args is a named list with name NA and object NA.
  # The resulting error occurs down below and is:
  # Error in thisCall[[arg]] <- args[[arg]] : subscript out of bounds
  if (!is.null(names(gFunc_args))) {
    gFunc_args <- gFunc_args[!is.na(names(gFunc_args))]
  }
    
  gm <- paste0(".", names(x))
  
  dims <- dims(x)
  
  is_1d_gate <- length(dims) == 1
  
  popAlias <- alias(gtPop)
  popName <- names(gtPop)
  popId <- gtPop@id
  gs_nodes <- basename(getChildren(y[[1]], parent))
  
  if (length(gs_nodes) == 0)
    isGated <- FALSE
  else
    isGated <- any(popAlias %in% gs_nodes)
    
  if(!isGated)
  {
    message("Gating for '", popAlias, "'")
    
    parent_data <- getData(y, parent)
    parallel_type <- match.arg(parallel_type)
    ## get the accurate channel name by matching to the fr
    frm <- parent_data[[1, use.exprs = FALSE]]
    channels <-  unname(sapply(dims, function(channel)as.character(getChannelMarker(frm, channel)$name)))
    
    parent_data <- parent_data[, channels] #it is more efficient to only pass the channels of interest
    # Splits the flow set into a list.
    # By default, each element in the list is a flowSet containg one flow frame,
    # corresponding to the invidual sample names.
    # If 'split' is given, we split using the unique combinations within pData.
    # In this case 'split' is specified with column names of the pData.
    # For example, "PTID:VISITNO"
    # when split is numeric, do the grouping by every N samples
    groupBy <- groupBy(x)
    isCollapse <- isCollapse(x)
    if (groupBy != "" && isCollapse) {
      #when x@collapse == FALSE,then ignore groupBy argument since grouping is only used for collapsed gating
      split_by <- as.character(groupBy)
      split_by_num <- as.numeric(split_by)
      #split by every N samples
      if(!is.na(split_by_num)){
            nSamples <- length(parent_data)
            if(nSamples==1){
              split_by <- 1
            }else{
              split_by <-  sample(rep(1:nSamples, each = split_by_num, length.out= nSamples))  
            }
            
      }else{
        #split by study variables
        split_by <- strsplit(split_by, ":")[[1]]
        split_by <- apply(pData(parent_data)[, split_by, drop = FALSE], 1, paste, collapse = ":")
        split_by <- as.character(split_by)
      }
    } else {
      split_by <- sampleNames(parent_data)
    }

    fslist <- split(parent_data, split_by)
    
    if(is.null(pp_res))
      pp_res <- sapply(names(fslist),function(i)pp_res)
    else
      pp_res <- pp_res[names(fslist)] #reorder pp_res to make sure it is consistent with fslist
    # construct method call
    thisCall <- substitute(f1(fslist,pp_res))
    thisCall[["FUN"]] <- as.symbol(".gating_adaptor")
    # args to be passed to gating_adaptor
    args <- list()
    args[["gFunc"]] <- gm  #set gating method
    args[["popAlias"]] <- popAlias  
    args[["channels"]] <- channels 
    
    
    if (is_1d_gate) {
      if (grepl("-$", popName)) {
        positive <- FALSE
      } else if (grepl("\\+$", popName)) {
        positive <- TRUE
      } else {
        stop("Invalid population name! Name should end with '+' or '-' symbol.")
      }
      
      gFunc_args[["positive"]] <- positive
    }
    args[["gFunc_args"]] <- gFunc_args
    
    thisCall[["MoreArgs"]] <- args
    
    ## choose serial or parallel mode
    
      
    if (parallel_type == "multicore") {
      message("Running in parallel mode with ", mc.cores, " cores.")
      thisCall[[1]] <- quote(mcmapply)
      thisCall[["mc.cores"]] <- mc.cores
    }else if(parallel_type == "cluster"){
      if(is.null(cl))
          stop("cluster object 'cl' is empty!")
        thisCall[[1]] <- quote(clusterMap)
        thisCall[["cl"]] <- cl
        thisCall[["fun"]] <- thisCall[["FUN"]] 
        thisCall[["FUN"]] <- NULL
        thisCall[["SIMPLIFY"]] <- TRUE
     }else {
      thisCall[[1]] <- quote(mapply)  #select loop mode
  
     }
    
    flist <- eval(thisCall)

    # Handles the case that 'flist' is a list of lists.
    #   The outer lists correspond to the split by pData factors.
    #   The inner lists contain the actual gates.
    #     The order do not necessarily match up with sampleNames()
    # Unforunately, we cannot simply use 'unlist' because the list element names
    # are mangled.
    
    if (all(sapply(flist, is.list))) {
      flist <- do.call(c, unname(flist))
    }
    #check failed sample 
    #eventually we want to handle this properly (like inserting dummy gates)
    #in order for the other samples proceed the gating
    failed <- sapply(flist, function(i)extends(class(i), "character"))
    if(any(failed)){
      print(flist[failed])
      stop("some samples failed!")
      
    }
    
    #this is flowClust-specific operation, which
    # be abstracted out of this framework
    if (extends(class(flist[[1]]), "fcFilter")) {
      flist <- fcFilterList(flist)
    }
    
    
    
    
    if(length(popAlias) == 1){
      #when Alias is meta character, then pass NULL
      # to add method which uses filterId slot to name the populations
      if(popAlias == "*")
        popAlias <- NULL  
    }
    
    gs_node_id <- add(y, flist, parent = parent, name = popAlias, validityCheck = FALSE, recompute = TRUE)
    message("done.")
    
  }else{
    
    message("Skip gating! Population '", paste(popAlias, collapse = ","), "' already exists.")
    flist <- NULL
  }
  
  flist
}

#' apply a \code{boolMethod} to the \code{GatingSet}
#' 
#' @param x \code{boolMethod}
#' @inheritParams .gating_boolMethod
#' @param ... other arguments
#' @aliases
#' gating,boolMethod,GatingSet-method
#' gating,boolMethod,GatingSetList-method
setMethod("gating", signature = c("boolMethod", "GatingSet"),
    definition = function(x, y, ...) {
      .gating_boolMethod(x,y,...)      
    })
setMethod("gating", signature = c("boolMethod", "GatingSetList"),
    definition = function(x, y, ...) {
      .gating_boolMethod(x,y,...)      
    })

#' internal function (gating_boolMethod)
#' 
#'  @param y \code{GatingSet}
#'  @param gtPop a \code{gtPopulation} object that contains the information of the cell population that is going to be generated by this gating method.
#'  @param  parent \code{character} specifying the parent node within \code{GatingSet} to which the new popoulation is to be attached.
.gating_boolMethod <- function(x, y, gtPop, parent, ...) {
  
  args <- parameters(x)[[1]]
  gm <- paste0(".", names(x))
  popAlias <- alias(gtPop)
  popName <- names(gtPop)
  popId <- gtPop@id
  
  gs_nodes <- basename(getChildren(y[[1]], parent))
  tNodes <- deparse(args)
  if (!(popAlias %in% gs_nodes)) {
    message(popAlias, " gating...")
    bf <- eval(substitute(booleanFilter(x), list(x = args)))
    bf@filterId <- tNodes
    #set recompute to FALSE because we want recompute method take over the
    #computing job since it is smart on determining whehter flow data needs to be loaded
    #for boolean gates
    invisible(gs_node_id <- add(y, bf, parent = parent, name = popAlias))
    newNode <- file.path(parent, popAlias)
    invisible(recompute(y, newNode))
    message("done.")
  } else {
    message("Skip gating! Population '", popAlias, "' already exists.")
  }
  
  # gs_node_id
  NULL
}

#' apply a \code{polyFunctions} gating method to the \code{GatingSet}
#' 
#' It generates a batch of \code{boolMethod}s based on the expression defined in \code{polyFunctions} objects.
#' It is a convenience way to generate different boolean combinations of cytokine gates. 
#' 
#' @param x \code{polyFunctions}
#' @inheritParams .gating_polyFunctions
#' @param ... other arguments
#' @aliases
#' gating,polyFunctions,GatingSet-method
#' gating,polyFunctions,GatingSetList-method
setMethod("gating", signature = c("polyFunctions", "GatingSet"),
    definition = function(x, y, ...) {
      .gating_polyFunctions(x,y,...)      
    })
setMethod("gating", signature = c("polyFunctions", "GatingSetList"),
    definition = function(x, y, ...) {
      .gating_polyFunctions(x,y,...)      
    })

#' internal function (gating_polyFunctions)
#' 
#'  @param y \code{GatingSet}
#'  @param gtPop a \code{gtPopulation} object that contains the information of the cell population that is going to be generated by this gating method.
#'  @param  parent \code{character} specifying the parent node within \code{GatingSet} to which the new popoulation is to be attached.
#' @importFrom gtools permutations 
.gating_polyFunctions <- function(x, y, gtPop, parent, ...) {
  
  refNodes <- x@refNodes
  popAlias <- alias(gtPop)
  message("Population '", paste(popAlias, collapse = ","), "'")
  
  nMarkers <- length(refNodes)

  ## all the comibnations of A & B & C
  opList <- permutations(n = 1, r = nMarkers - 1, c("&"), repeats.allowed = TRUE)
  isNotList <- permutations(n = 2, r = nMarkers, c("!", ""), repeats.allowed = TRUE)
  polyExprsList <- apply(opList, 1, function(curOps) {
    apply(isNotList, 1, function(curIsNot) {
      polyExprs <- curIsNot
      polyExprs[-1] <- paste0(curOps, curIsNot[-1])
      
      paste(paste0(polyExprs, refNodes), collapse = "")
    })
  })
  polyExprsList <- as.vector(polyExprsList)
  
  gs_nodes <- basename(getChildren(y[[1]], parent))
  # actual gating
  lapply(polyExprsList, function(polyExpr) {
    
    #replace the slash with colon 
    #since forward slash is reserved for gating path
    if(grepl("/",polyExpr)){
      old_name <- polyExpr
      new_name <- gsub("/",":",polyExpr)
      warning(old_name, " is replaced with ", new_name)
    }else
      new_name <- polyExpr
#    browser()
    
    isExist <- new_name %in% gs_nodes
    if (!isExist) {
      message("adding ", new_name, " ...")

      bf <- char2booleanFilter(polyExpr)

      invisible(gs_node_id <- .addGate_fast(y, bf, parent = parent, name = polyExpr))
      
  
    } else {
      message("Skip!Population '", new_name, "' already exists.")
    }        
  })
  #to reduce overhead,compute from parent node once instead of do it multiple times for each individual new bool gate
    
  invisible(recompute(y, parent))
  message("done.")
  
  list()
}

#' apply a \code{refGate} to the \code{GatingSet}
#' 
#' @param x \code{refGate}
#' @inheritParams .gating_refGate
#' @param ... other arguments
#' 
#' @aliases
#' gating,refGate,GatingSet-method
#' gating,refGate,GatingSetList-method
#' gating,dummyMethod,GatingSet-method
#' gating,dummyMethod,GatingSetList-method
setMethod("gating", signature = c("refGate", "GatingSet"),
    definition = function(x, y, ...) {
      .gating_refGate(x, y, ...)
    })
setMethod("gating", signature = c("refGate", "GatingSetList"),
    definition = function(x, y, ...) {
      .gating_refGate(x, y, ...)
    })

setMethod("gating", signature = c("dummyMethod", "GatingSet"),
    definition = function(x, y, ...) {
      #do nothing
    })

setMethod("gating", signature = c("dummyMethod", "GatingSetList"),
    definition = function(x, y, ...) {
      #do nothing
    })

#' internal function (gating_refGate)
#' 
#'  @param y \code{GatingSet}
#'  @param gtPop a \code{gtPopulation} object that contains the information of the cell population that is going to be generated by this gating method.
#'  @param  parent \code{character} specifying the parent node within \code{GatingSet} to which the new popoulation is to be attached.
.gating_refGate <- function(x, y, gtPop, parent, ...) {
#  negated <- FALSE
  refNodes <- x@refNodes
  popAlias <- alias(gtPop)
  popName <- names(gtPop)
  dims <- dims(x)
  
  my_gh <- y[[1]] 
  gs_nodes <- basename(getChildren(my_gh, parent))
  if (length(gs_nodes) == 0 || !popAlias %in% gs_nodes) {
    
    message("Population '", paste(popAlias, collapse = ","), "'")
    if (length(refNodes) > 2) {
      stop("Not sure how to construct gate from more than 2 reference nodes!")
    }
    
    fr <- getData(my_gh, use.exprs = FALSE)
    
    #check if parent node is shared 
    #to determine whether simply grab the indices from ref nodes without recompute
    ref_parents <- sapply(refNodes, function(refNode)getParent(my_gh, refNode))
    isSameParent <- all(ref_parents == parent)
    flist <- flowWorkspace::lapply(y, function(gh) {
          
       glist <- lapply(refNodes, function(refNode) {
          
          getGate(gh, refNode)
        })
       
      # standardize the names for the gate parameters and dims
      gate_params <- unlist(lapply(glist, function(g) {
        cur_param <- parameters(g)
        getChannelMarker(fr, cur_param)["name"]
      }))

      if(length(glist)==1){
        #1d ref gate
        dims <- dims[!is.na(dims)]
        nDims <- length(dims)
        
        pos_token <- "[\\+]"
        neg_token <- "[\\-]"
        pop_name_pat <- "[^\\+-]+"
        pos_pop_pat <- paste(pop_name_pat, pos_token, sep = "")
        neg_pop_pat <- paste(pop_name_pat, neg_token, sep = "")
        
        if(nDims==2){
          #set negated flag of outer scope when necessary
#          if (grepl(neg_pop_pat,popName)&&!negated) {
#            negated <<- TRUE
#          }
          #before flowCore and flowViz support the negated filter
          #we use refGate+boolGate in csv template as the workaround
          if (grepl(neg_pop_pat,popName)) {
            stop("negated 2d gate is not supported yet!")
          }
          #pass the gate as it is 
          glist[[1]]
        }else{
          dim_params <-  getChannelMarker(fr, dims)["name"]
          y_g <- glist[[1]]               
          y_coord <- c(y_g@min, y_g@max)
          cut.y <- y_coord[!is.infinite(y_coord)]
          
          
          if (grepl(pos_pop_pat,popName)) {
            #handle all infinite coordinates
            if(length(cut.y) == 0)
              cut.y <- -Inf
            gate_coordinates <- list(c(cut.y, Inf))
          } else if(grepl(neg_pop_pat,popName)){
            if(length(cut.y) == 0)
              cut.y <- Inf
            gate_coordinates <- list(c(-Inf, cut.y))
          }else{
            stop("unknown population pattern, ",popName)
          }
          names(gate_coordinates) <- as.character(dim_params)
          
          rectangleGate(gate_coordinates)  
        }
        
      }else{
          #2d quad gate
          dim_params <- unlist(lapply(dims, function(dim) {
                    getChannelMarker(fr, dim)["name"]
                  }))
          
          # match the gate param to dims to find gates for x, y dimensions
          x_ref_id <- match(dim_params[1], gate_params)
          y_ref_id <- match(dim_params[2], gate_params)
          x_g <- glist[[x_ref_id]]
          y_g <- glist[[y_ref_id]]
                        
          
          # pick the non-infinite coordinate as the cut points
          x_coord <- c(x_g@min, x_g@max)
          y_coord <- c(y_g@min, y_g@max)
          x_inf_vec <- is.infinite(x_coord)
          y_inf_vec <- is.infinite(y_coord)
          cut.x <- x_coord[!x_inf_vec]
          cut.y <- y_coord[!y_inf_vec]
          
          # In order, the following vector has the patterns:
          # 1. top left (-+)
          # 2. top right (++)
          # 3. bottom right (+-)
          # 4. bottom left (--)
          quadPatterns <- c(".+-.+\\+$", ".+\\+.+\\+$", ".+\\+.+-$", ".+-.+-$")
          
          # check if popname is give as Y[*]X[*]
          YX_pattern <- paste0(dims[2], ".+", dims[1], ".+")
          XY_pattern <- paste0(dims[1], ".+", dims[2], ".+")
          
          # do the flipping if YX
          if (grepl(YX_pattern, popName)) {
            pos <- regexpr(dims[1], popName)
            xterm <- substring(popName, pos, nchar(popName))
            yterm <- substring(popName, 1, pos - 1)
            toMatch <- paste(xterm, yterm, sep = "")
          } else if (grepl(XY_pattern, popName)) {
            toMatch <- popName  #keep as it is if XY
          }
          else {
            stop("X,Y axis do not match between 'dims'(", paste(dims, collapse = ","), 
                ") and 'pop'(", popName, ")")
          }
          quadInd <- which(unlist(lapply(quadPatterns, grepl, toMatch)))
          
          #get event indices for both ref nodes
#          x_event_ind <- getIndices(gh, refNodes[x_ref_id])
#          y_event_ind <- getIndices(gh, refNodes[y_ref_id])
          
          x_ref <- refNodes[x_ref_id] 
          y_ref <- refNodes[y_ref_id]
          #standardize event ind to x+ and y+
          #by checking the positive sign of both reference gates
          #to prepare for the bool operation later
          if(length(cut.x) == 0){
          #handle dummy ref gate that has both boudnary as Inf
#            x_event_ind <- TRUE           
            x_ref <- NULL
          }else{
            x_ref_pos <- which(x_inf_vec) == 2
          }
          if(length(cut.y) == 0){
#            y_event_ind <- TRUE
              y_ref <- NULL
          }else{
            y_ref_pos <- which(y_inf_vec) == 2
          }
          
#          browser()
          # construct rectangleGate from reference cuts
          if (quadInd == 1) {
            #handle all infinite coordinates
            if(length(cut.x) == 0)
              cut.x <- Inf
            else
            {
              if(x_ref_pos)
                x_ref <- paste0("!", x_ref) #x-
            }
              
            if(length(cut.y) == 0)
              cut.y <- -Inf
            else
            {
              if(!y_ref_pos)
                y_ref <- paste0("!", y_ref) #y+ 
            }
            coord <- list(c(-Inf, cut.x), c(cut.y, Inf))
            
          } else if (quadInd == 2) {
            #handle all infinite coordinates
            if(length(cut.x) == 0)
              cut.x <- -Inf
            else
            {
              if(!x_ref_pos)#x+
                x_ref <- paste0("!", x_ref) 
            }
            if(length(cut.y) == 0)
              cut.y <- -Inf
            else
            {
              if(!y_ref_pos)#y+
                y_ref <- paste0("!", y_ref) 
            }
            coord <- list(c(cut.x, Inf), c(cut.y, Inf))
            
          } else if (quadInd == 3) {
            #handle all infinite coordinates
            if(length(cut.x) == 0)
              cut.x <- -Inf
            else
            {
              if(!x_ref_pos)#x+
                x_ref <- paste0("!", x_ref) 
            }
            if(length(cut.y) == 0)
              cut.y <- Inf
            else
            {
              if(y_ref_pos)#y-
                y_ref <- paste0("!", y_ref) 
            }
            coord <- list(c(cut.x, Inf), c(-Inf, cut.y))
             
          } else if (quadInd == 4) {
            #handle all infinite coordinates
            if(length(cut.x) == 0)
              cut.x <- Inf
            else
            {
              if(x_ref_pos)#x-
                x_ref <- paste0("!", x_ref) 
            }
            if(length(cut.y) == 0)
              cut.y <- Inf
            else
            {
              if(y_ref_pos)#y-
                y_ref <- paste0("!", y_ref) 
            }
            coord <- list(c(-Inf, cut.x), c(-Inf, cut.y))
            
          } else stop("Pop names does not match to any quadrant pattern!")
          
          names(coord) <- as.character(dim_params)
          fres <- rectangleGate(coord)
          if(isSameParent&&!is.null(x_ref)&&!is.null(y_ref)){
            fres <- ocRectRefGate(fres, paste0(x_ref, "&", y_ref))
            fres
          }
          
        fres  
      }
      
    })
    
    flist <- filterList(flist)
    gs_node_id <- add(y, flist, parent = parent, name = popAlias, validityCheck = FALSE, recompute = TRUE)
    
    
  } else {
    message("Skip gating! Population '", popAlias, "' already exists.")
    flist <- NULL
  }

  message("done.")
  flist
}

